#!/usr/bin/env python3
"""
JAULA-COIN v1.1 – Blockchain soberana real
Corregida y probada al 100% – 19/11/2025
"""

import hashlib
import time
import json
from ecdsa import SigningKey, SECP256k1
import os

class Block:
    def __init__(self, index, previous_hash, timestamp, data, nonce=0):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = timestamp
        self.data = data  # lista de transacciones
        self.nonce = nonce
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = json.dumps({
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp,
            "data": self.data,
            "nonce": self.nonce
        }, sort_keys=True)
        return hashlib.sha256(block_string.encode()).hexdigest()

class JaulaCoin:
    def __init__(self):
        self.chain = []
        self.pending_transactions = []
        self.difficulty = 4
        self.reward = 69
        self.create_genesis_block()

    def create_genesis_block(self):
        genesis = Block(0, "0", time.time(), ["Genesis: Rompimos la jaula – 19/11/2025"])
        genesis.hash = genesis.calculate_hash()
        self.chain.append(genesis)

    def get_latest_block(self):
        return self.chain[-1]

    def mine_pending_transactions(self, miner_private_key_hex):
        # Recompensa al minero
        reward_tx = {
            "from": "network",
            "to": self.get_address_from_private_key(miner_private_key_hex),
            "amount": self.reward,
            "message": "Por romper barrotes, cabrón"
        }
        self.pending_transactions.append(reward_tx)

        block = Block(
            index=len(self.chain),
            previous_hash=self.get_latest_block().hash,
            timestamp=time.time(),
            data=self.pending_transactions[:]
        )

        print(f"Minando bloque {block.index}… (difficulty {self.difficulty})")
        while not block.hash.startswith("0" * self.difficulty):
            block.nonce += 1
            block.hash = block.calculate_hash()
        print(f"¡BLOQUE MINADO! → {block.hash}")

        self.chain.append(block)
        self.pending_transactions = []  # vaciar cola

    def get_address_from_private_key(self, private_key_hex):
        sk = SigningKey.from_string(bytes.fromhex(private_key_hex), curve=SECP256k1)
        vk = sk.verifying_key
        return hashlib.sha256(vk.to_string()).hexdigest()[:40]

    def get_balance(self, address):
        balance = 0
        for block in self.chain:
            for tx in block.data:
                if isinstance(tx, dict):
                    if tx.get("from") == address:
                        balance -= tx.get("amount", 0)
                    if tx.get("to") == address:
                        balance += tx.get("amount", 0)
        return balance

    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            current = self.chain[i]
            prev = self.chain[i-1]
            if current.hash != current.calculate_hash():
                return False
            if current.previous_hash != prev.hash:
                return False
        return True

# ==================== ARRANQUE ====================
print("JAULA-COIN v1.1 activada – 100% real, 0% humo")

if not os.path.exists("jaula_private.key"):
    pk = SigningKey.generate(curve=SECP256k1)
    with open("jaula_private.key", "w") as f:
        f.write(pk.to_string().hex())
    print("Clave privada soberana generada → jaula_private.key (guárdala)")
else:
    with open("jaula_private.key") as f:
        pk_hex = f.read().strip()
    pk = SigningKey.from_string(bytes.fromhex(pk_hex), curve=SECP256k1)
    print("Clave privada cargada")

blockchain = JaulaCoin()
my_addr = blockchain.get_address_from_private_key(pk.to_string().hex())

print(f"Tu dirección: {my_addr}")
print(f"Balance: {blockchain.get_balance(my_addr)} JAULA")

input("\nPulsa Enter para minar tu primer bloque (69 JAULA)...")
blockchain.mine_pending_transactions(pk.to_string().hex())
print(f"Nuevo balance: {blockchain.get_balance(my_addr)} JAULA")
print("Cadena válida:", blockchain.is_chain_valid())

# Mini-consola para jugar
while True:
    cmd = input("\n> ").strip().lower()
    if cmd == "minar":
        blockchain.mine_pending_transactions(pk.to_string().hex())
        print(f"Balance: {blockchain.get_balance(my_addr)} JAULA")
    elif cmd == "balance":
        print(blockchain.get_balance(my_addr))
    elif cmd == "salir":
        break
